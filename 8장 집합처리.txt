Make-Set(x) : 원소 x로만 이루어진 집합 {x} 를 만드는 연산
1. 노드를 하나 만들어 해당 원소를 저장
2. 부모 링크는 자신을 가리키도록 함


{a, b, c, h}
{d, e, f, g}
일 떄


Find-Set(a): 원소 a가 속한 집합을 알아냄 → 대표 원소 c
Find-Set(e): 원소 e가 속한 집합을 알아냄 → 대표 원소 e
Find-Set(g): 원소 g가 속한 집합을 알아냄 → 대표 원소 e



Union 예

{a, b, c, h} 대표원소는 c
{d, e, f, g} 대표원소는 e


Union(a, g)


{a, b, c, h, d, e, f, g} 대표원소는 c (e가 c를 가리킴)


Tree이용한 집합 처리 알고리즘


Make-Set(x) ▷ 노드 x를 유일한 원소로 하는 집합을 만든다. 
{
   x.parent ← x ; 
} 

Union(x, y) ▷ 노드 x가 속한 집합에 노드 y가 속한 집합을 합친다.
{ 
   Find-Set(y).parent ← Find-Set(x); 
	y'                    x'
}
Find-Set(x) ▷ 노드 x가 속한 집합을 알아낸다. 
즉, 노드 x가 속한 트리의 루트 노드를 리턴한다. 
{ 
if (x = x.parent) 
then return x ; 
else return Find-Set(x.parent); 
}



[참고] 원소가 a->b->c트리인 경우 (루트원소  c)
Find-Set(x) { 
if (x = x.parent) then return x ; 
else return Find-Set(x.parent) ; 
} 
Find-Set(x) { 
if (x = x.parent) then return x ; 
else return Find-Set(x.parent) ; 
} 
Find-Set(x) { 
if (x = x.parent) then return x ; 
else return Find-Set(x.parent) ; 
} 
y = Find-Set(a);

연산의 효율을 높이는 방법
• Tree를 이용한 집합 처리에서 연산의 효율을 높
이는 방법 두가지
(1) 랭크(rank)를 이용한 Union				
• Union 연산을 수행하여 트리가 확장될 때, 트리의			<--트리의 높이를 낮추는 두가지 방법	
높이를 가능한 낮게 유지할 수 있도록 함
(2) 경로 압축(path compression)
• Find-Set 연산을 수행하는 과정에서 경로의 길이를
줄임


(1) 랭크를 이용한 Union
Union 연산시 트리의 높이를 가능한 낮게 유지할 수 있도
록 rank라는 개념을 이용
랭크(rank)
– 각 노드에 랭크(rank)라는 이름의 필드를 두어
자신을 루트로 하는 서브트리의 높이를 저장한
다.
– 이 때 하나의 노드로 이루어진 트리(서브트리)
의 높이는 0이라고 정의한다.
• 집합의 랭크(rank)
– 루트 노드의 rank가 그 집합의 rank이다.
• 랭크를 이용한 Union
– Union 연산시 rank가 낮은 집합을 rank가 높은
집합에 붙인다.



(2) 경로 압축(path compression)

Find-Set 연산시 경로의 길이를 줄이는 시도를 함
– Find-Set을 수행하는 과정에서 만나는 모든 노드들에
대해, 현재 부모를 가리키는 대신, 직접 root를 가리키
도록 parent 포인터를 바꾸어 준다.
– 이 과정에서 트리의 높이가 줄어들 가능성이 높다.



(1) 랭크를 이용한 Union - 알고리즘
Make-Set(x) ▷ 노드 x를 유일한 원소로 하는 집합을 만든다. 
{ 
   x.parent ← x; 
   x.rank ← 0; 
}

Union(x, y) ▷ 노드 x가 속한 집합과 노드 y가 속한 집합을 합친다.
{ 
   x' ← Find-Set(x); 
   y' ← Find-Set(y); 
   if (x'.rank > y'.rank) 
      then y'.parent ← x' ; 
   else { 
      x'.parent ← y' ; 
      if (x'.rank = y'.rank) then y'.rank ← y'.rank + 1; 
         } 
} 
Find-Set(x) ▷ 랭크를 이용하지 않은 알고리즘과 동일




(2) 경로 압축을 이용한 Find-Set – 알고리즘
Find-Set(x) ▷ 노드 x가 속한 집합을 알아낸다.  즉, 노드 x가 속한 트리의 루트 노드를 리턴한다. 
{ 
   if (x.parent ≠ x) then ▷ x가 대표 원소(루트 노드)가 아니면
        x.parent ← Find-Set(x.parent); ▷ x의 parent의 대표 원소를 찾아 x의 parent로 삼음
   return x.parent; 
}



비교: 경로 압축을 이용하지 않은 기존 Find-Set
Find-Set(x) { 
   if (x = x.parent) 
     then return x ; 
     else return Find-Set(x.parent);
}



[정리 8-2]
• 랭크를 이용한 Union을 사용하면, 랭크가 k인 노드를 대
표로 하는 집합의 원소 수는 최소한 2
k 개다.
[정리 8-3]
• 랭크를 이용한 Union 을 사용하면, 원소 수가 n인 집합을
표현하는 트리에서 임의의 노드의 랭크는 O(log n)이다.
[정리 8-4]
• 랭크를 이용한 Union을 사용할 때, m번의 Make-Set, 
Union, Find-Set 중 n번이 Make-Set이라면, 이들의 총 수행
시간은 O(m log n)이다.
[정리 8-5]
• Tree로 표현한 배타적 집합에서 랭크를 이용한 Union과
경로압축을 이용한 Find-Set을 동시에 사용하면, m번의
Make-Set, Union, Find-Set 중 n번이 Make-Set일 때 이들의
총 수행시간은 O(m log*n).

-->log*n 은 “로그스타 n” 이라고 읽고, 다음과 같이 정의된다.
log*n = min {k : loglog …logn ≤ 1}

[이 정리의 의미]
• 현실적인 n 값에 대해 log*n 는 상수라고 봐도 될 정도로
작은 값이다. 예) ) log* 2^65536 = 5(log 2^65536에 로그를 5번 씌우면 1이 나오므로 로그스타 n 값은 5) 
참고: 65536 = 2^16
• 따라서 O(m log*n)은 사실상 O(m), 즉 선형시간임
– m 번의 연산을 수행하는 시간이 O(m)이므로 각 연산에 평균 상수
시간이 걸린다.



요약

상호 배타적 집합을 표현하는 대표적인 방법은 연결 리스트를 이용한 방법, 트리를 이용한 방법이다.
• 상호 배타적 집합 처리에 필요한 작업은 Make-Set, 
Find-Set, Union
• 연결 리스트를 이용한 방법은 잘 구현하면 Make-Set, 
Find-Set은 O(1), Union은 평균 O(log n)
• 트리를 이용한 방법은 잘 구현하면 m번의 Make-Set, 
Find-Set, Union 작업에 O(m)
